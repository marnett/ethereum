\documentclass[11pt]{article}
\usepackage{listings}
\usepackage{fullpage}
\usepackage{framed}

\begin{document}

\section{Basic Serpent Contract Example}
Before moving into more difficult examples, let's take a quick look at an Easy Bank example from KenK's first tutorial. A contract like this allows for a fully transparent bank to function with an open ledger that can be audited by any node on the network (an ideal feature for ensuring banks aren't laundering money or lending to enemies of the state.)

Before looking at the code for the contract, let's define our "easy bank" further. Our bank will be using its own contracual currency and not Ether (which we will dicuss and implement in a later contract example). So creating the currency is done within our contract. Now that we know what our bank does (create and send a currency that is exclusive to the contract), let's define what the contract must be capable of doing:
\begin{enumerate}
\item Setup at least one account with an initial balance of our contract-exclusive currency
\item Take funds from one account and send our currency to another account
\end{enumerate}


\begin{lstlisting}[frame=single]
def init():
	self.storage[msg.sender] = 10000
	self.storage["Taylor"] = 0
def send_currency_to(value):
	to = "Taylor"
	from = msg.sender
	amount = value
	if self.storage[from] >= amount:
		self.storage[from] = self.storage[from]  - amount
		self.storage[to] = self.storage[to] + amount
\end{lstlisting}
		
		
So what's going on in this contract?
Our contract is divided into two methods, let's take a look at the first method:

\begin{lstlisting}
def init():
	self.storage[msg.sender] = 10000
	self.storage["Taylor"] = 0
\end{lstlisting}
	
The init function in serpent is very similar to init in python, which is very similar to common constructors in Java. The init function runs once and only once at contract creation. In our contract the init block runs and instantiates two objects in contract storage.
 
Our init method, from a general perspective, intializes one account with a balance of 10,000U (this will be how we donote our contract-exclusive currency) and another account with a balance of 0U. In our Ethereum contract, storage is handled with key value pairs. Every contract has their own storage which is accessed by calling self.storage[key]. So in our example the easy bank's contract storage now has a value of 10,000U at key msg.sender (we'll identify what this is in a moment) and at the key "Taylor" there is a value of 0U. 

 Awesome. So who is msg.sender? msg.sender is the person who is sending the specific message to the contract - which in this case is us. msg.sender is unique and assigned and verified by the network. We now have a heightened understanding of init, lets look at our send method.

 \clearpage

\begin{lstlisting}
def send_currency_to(value):
	to = "Taylor"
	from = msg.sender
	amount = value
	if self.storage[from] >= amount:
		self.storage[from] = self.storage[from]  - amount
		self.storage[to] = self.storage[to] + amount
\end{lstlisting}

Let's take a look at this one piece at a time. The first three lines aim are setting up variables that we will use in the last three lines. The first line is establishing who we are sending our funds to - and just as we setup in init, we are sending our funds to our friend Taylor. 
from is being set to the address that the funds are from, which is us - msg.sender. Finally, the value variable is set to the parameter passed to our send\_currency\_to function. When the contract was invoked a value needed to be sent in order for it to run properly, this value is the value that is going to be sent to Taylor.

Okay, now that we understand what variables we are working with let's dive into the last portion of our contract. We want to check that the balance for the bank account in the contract's storage at from (remember that you are who this is from!) is greater than or equal to the amount we are attempting to send - obviously we do not want our contract sending money that the sender does not have.

If the account balance passes our check we subtract the amount being sent from the sender balance: self.storage[from] = self.storage[from] - value. We then add to the balance of the account receiving the currency: self.storage[to] = self.storage[to] + value.

Great! We have officially worked our way through a very basic contract example! Now our friend Taylor has 1000U! Try to think of ways that you could improve this contract, here are some things to consider:

\begin{itemize}
\item What happens when the value exceeds the amount setup in the 'from' account?
\item What happens when the value is negative?
\item What happens when value isn't a number?
\end{itemize}


\section{Moderate Serpent Contract Example}

	So we've made it through the first serpent example, which we now have realized wasn't as daunting as it first seemed. We understand that every contract has its own contractual storage that is accessed through self.storage[key] = value. We understand that arguments passed to a contract are stored in the array msg.data[arg \#], which is similar to Java's String[] args. Lastly we understand that msg.sender gives us the unique identifier of whoever sent the message, and that all participants involved with a  contract have their own unique identifier that can be used in whatever creative way you would like. \\

Let's look at a more moderate contract that keeps with our bank theme. So, just like with our first contract, we need to classify what we are making and what characteristics the contract will need to leverage our desired features. We are going to be implementing what is known as a mutual credit system. A generalized idea of a mutual credit system is the intersection of a barter system and a non-regulated currency model. So, let?s define a community that implements a mutual credit system and every participant gets a 1000 Unit credit (in this case 1UC = 1USD). In the beginning there is no money at all. It only comes into circulation when one of the participants uses his credit to pay another participant. If he uses his 1000 Units his balance is ? 1000 U. His supplier?s balance is now +1000U. The total amount in circulation is now also 1000 U. This means there is always exactly as much in circulation as there is outstanding credit: a zero sum game.

One can clearly notice that this system creates money at the time of the transaction. At time 0, before any of the community's participants completed a transaction, the currency in circulation was zero. It is also clear that, unlike fiat currencies, this model does not require any centralized money supply management, which when discussing decentralized apps running on blockchain technology is an attractive idea to implement. Regardless of your opinion on such a system, let's automate a contract to initiate these transactions and act as a public ledger to keep track of the community's participants and their account balances. 


\clearpage

\begin{lstlisting}[frame=single]
def init():
	contract.storage[((msg.sender * 0x10) + 0x1)] = 0x1
	contract.storage[((msg.sender * 0x10) + 0x2)] = 0x1

def code():
	toAsset = (msg.data[0] * 0x10) + 0x1
	toDebt = (msg.data[0] * 0x10) + 0x2
	fromAsset = (msg.sender * 0x10) + 0x1
	fromDebt = (msg.sender * 0x10) + 0x2
	value = msg.data[1]
	
	if contract.storage[fromAsset] >= value:
		contract.storage[fromAsset] = contract.storage[fromAsset] - value 
	else:
		contract.storage[fromDebt] = value - contract.storage[fromAsset]
		contract.storage[fromAsset] = 0
		
	if contract.storage[toDebt] >= value:
		contract.storage[toDebt] = contract.storage[toDebt] - value
	else:
		value = value - contract.storage[toDebt] 
		contract.storage[toAsset] = contract.storage[toAsset] + value
		contract.storage[toDebt] = 0
\end{lstlisting}


\end{document}